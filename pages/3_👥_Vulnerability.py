"""
Population Vulnerability Analysis Page
Displays elderly population and social vulnerability indicators
"""

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from pathlib import Path
import sys
import json

# Add parent directory to path
sys.path.append(str(Path(__file__).parent.parent))
from config import PROCESSED_DATA_DIR

# Page config
st.set_page_config(page_title="Population Vulnerability", page_icon="üë•", layout="wide")

st.title("üë• Population Vulnerability Analysis")
st.markdown("Analyze demographic vulnerability to heat stress")

# Load vulnerability data
@st.cache_data
def load_vulnerability_data():
    """Load Paris arrondissement vulnerability data"""
    vuln_file = PROCESSED_DATA_DIR / "paris_vulnerability.csv"
    if vuln_file.exists():
        return pd.read_csv(vuln_file)
    return None

@st.cache_data
def load_paris_boundaries():
    """Load Paris arrondissement geographic boundaries"""
    # Try full boundaries first
    boundaries_file = PROCESSED_DATA_DIR / "paris_arrondissements.geojson"
    if boundaries_file.exists():
        with open(boundaries_file, 'r', encoding='utf-8') as f:
            return json.load(f), 'polygon'

    # Fall back to point data
    points_file = PROCESSED_DATA_DIR / "paris_arrondissements_points.geojson"
    if points_file.exists():
        with open(points_file, 'r', encoding='utf-8') as f:
            return json.load(f), 'point'

    return None, None

vuln_data = load_vulnerability_data()

if vuln_data is not None:
    st.success(f"‚úÖ Loaded data for {len(vuln_data)} Paris arrondissements")
    
    # Overview metrics
    st.subheader("üìä Vulnerability Overview")
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric(
            "Total Population",
            f"{vuln_data['pop_total'].sum():,.0f}",
            help="Total population across all arrondissements"
        )
    
    with col2:
        st.metric(
            "Population 65+",
            f"{vuln_data['pop_65plus'].sum():,.0f}",
            help="Total elderly population"
        )
    
    with col3:
        avg_pct = vuln_data['pct_65plus'].mean()
        st.metric(
            "Avg % Elderly",
            f"{avg_pct:.1f}%",
            help="Average percentage of population aged 65+"
        )
    
    with col4:
        avg_vuln = vuln_data['vulnerability_score'].mean()
        st.metric(
            "Avg Vulnerability",
            f"{avg_vuln:.1f}/10",
            help="Average vulnerability score"
        )
    
    # Check if enhanced vulnerability data is available
    has_isolation_data = 'pct_elderly_living_alone' in vuln_data.columns
    has_enhanced_score = 'vulnerability_score_enhanced' in vuln_data.columns

    if has_isolation_data:
        with col4:
            avg_isolation = vuln_data['pct_elderly_living_alone'].mean()
            st.metric(
                "Avg % Living Alone",
                f"{avg_isolation:.1f}%",
                help="Average % of elderly (65+) living alone"
            )

    st.markdown("---")

    # Tabs
    tab1, tab2, tab3, tab4 = st.tabs(["üó∫Ô∏è Map View", "üìä By Arrondissement", "üìà Analysis", "üîù Rankings"])

    # TAB 1: Map View
    with tab1:
        st.subheader("üó∫Ô∏è Paris Arrondissements - Vulnerability Map")

        # Load geographic boundaries
        boundaries, geom_type = load_paris_boundaries()

        if boundaries is not None:
            # Prepare data for mapping
            map_data = vuln_data.copy()

            # Choose which vulnerability score to display
            if has_enhanced_score:
                score_column = 'vulnerability_score_enhanced'
                score_label = 'Enhanced Vulnerability Score'
                st.info("üìä **Enhanced Vulnerability Score** combines age-based vulnerability (60%) and isolation-based vulnerability (40%)")
            else:
                score_column = 'vulnerability_score'
                score_label = 'Vulnerability Score'

            # Add geographic coordinates from GeoJSON
            coords_map = {}
            for feature in boundaries.get('features', []):
                codgeo = feature['properties'].get('CODGEO')
                if codgeo and geom_type == 'point':
                    coords = feature['geometry']['coordinates']
                    coords_map[codgeo] = {'lon': coords[0], 'lat': coords[1]}

            if geom_type == 'point':
                # Scatter map for point data
                map_data['lon'] = map_data['CODGEO'].map(lambda x: coords_map.get(x, {}).get('lon'))
                map_data['lat'] = map_data['CODGEO'].map(lambda x: coords_map.get(x, {}).get('lat'))

                # Create scatter mapbox
                fig_map = px.scatter_mapbox(
                    map_data,
                    lat='lat',
                    lon='lon',
                    color=score_column,
                    size='pop_65plus',
                    hover_name='CODGEO',
                    hover_data={
                        'lat': False,
                        'lon': False,
                        'pop_total': ':,.0f',
                        'pop_65plus': ':,.0f',
                        'pct_65plus': ':.2f',
                        score_column: ':.1f',
                        'pct_elderly_living_alone': ':.2f' if has_isolation_data else False
                    },
                    color_continuous_scale='RdYlGn_r',
                    zoom=11,
                    center={'lat': 48.8566, 'lon': 2.3522},
                    title=f'{score_label} by Arrondissement',
                    labels={
                        score_column: score_label,
                        'pop_total': 'Total Population',
                        'pop_65plus': 'Population 65+',
                        'pct_65plus': '% Elderly',
                        'pct_elderly_living_alone': '% Elderly Alone'
                    }
                )

                fig_map.update_layout(
                    mapbox_style='open-street-map',
                    height=600,
                    margin={"r": 0, "t": 40, "l": 0, "b": 0}
                )

                st.plotly_chart(fig_map, use_container_width=True)

                st.info("‚ÑπÔ∏è **Note**: Displaying center points of arrondissements. For proper boundary visualization, download full geographic data using `scripts/download_paris_boundaries.py`")

            else:
                # Choropleth map for polygon data
                fig_map = px.choropleth_mapbox(
                    map_data,
                    geojson=boundaries,
                    locations='CODGEO',
                    featureidkey='properties.CODGEO',
                    color=score_column,
                    hover_name='CODGEO',
                    hover_data={
                        'pop_total': ':,.0f',
                        'pop_65plus': ':,.0f',
                        'pct_65plus': ':.2f',
                        score_column: ':.1f',
                        'pct_elderly_living_alone': ':.2f' if has_isolation_data else False
                    },
                    color_continuous_scale='RdYlGn_r',
                    zoom=11,
                    center={'lat': 48.8566, 'lon': 2.3522},
                    title=f'{score_label} by Arrondissement',
                    labels={
                        score_column: score_label,
                        'pop_total': 'Total Population',
                        'pop_65plus': 'Population 65+',
                        'pct_65plus': '% Elderly',
                        'pct_elderly_living_alone': '% Elderly Alone'
                    }
                )

                fig_map.update_layout(
                    mapbox_style='open-street-map',
                    height=600,
                    margin={"r": 0, "t": 40, "l": 0, "b": 0}
                )

                st.plotly_chart(fig_map, use_container_width=True)

            # Add legend
            st.markdown("---")
            st.markdown("### üìã Vulnerability Risk Categories")

            col1, col2, col3, col4, col5 = st.columns(5)
            with col1:
                st.markdown("üü¢ **Very Low**  \n0-2")
            with col2:
                st.markdown("üü° **Low**  \n3-4")
            with col3:
                st.markdown("üü† **Moderate**  \n5-6")
            with col4:
                st.markdown("üî¥ **High**  \n7-8")
            with col5:
                st.markdown("üî¥üî¥ **Very High**  \n9-10")

        else:
            st.warning("‚ö†Ô∏è Geographic boundary data not found. Please run `scripts/download_paris_boundaries.py` to enable map visualization.")

    # TAB 2: By Arrondissement
    with tab2:
        st.subheader("Vulnerability by Arrondissement")
        
        # Bar chart
        fig_bar = px.bar(
            vuln_data.sort_values('pct_65plus', ascending=False),
            x='CODGEO',
            y='pct_65plus',
            title='Percentage of Population 65+ by Arrondissement',
            labels={'CODGEO': 'Arrondissement', 'pct_65plus': '% Population 65+'},
            color='pct_65plus',
            color_continuous_scale='Blues',
            hover_data=['pop_total', 'pop_65plus']
        )
        fig_bar.update_layout(showlegend=False, xaxis_tickangle=-45)
        st.plotly_chart(fig_bar, use_container_width=True)
        
        # Data table
        st.markdown("**Detailed Data:**")

        # Build column list dynamically based on available data
        base_cols = ['CODGEO', 'pop_total', 'pop_65plus', 'pct_65plus']
        col_names = ['Arrondissement', 'Total Pop', 'Pop 65+', '% 65+']

        if has_isolation_data:
            base_cols.extend(['pct_elderly_living_alone', 'isolation_vulnerability'])
            col_names.extend(['% Elderly Alone', 'Isolation Score'])

        if has_enhanced_score:
            base_cols.append('vulnerability_score_enhanced')
            col_names.append('Enhanced Score')
        else:
            base_cols.append('vulnerability_score')
            col_names.append('Vulnerability Score')

        # Filter to only include columns that exist
        existing_cols = [col for col in base_cols if col in vuln_data.columns]
        display_data = vuln_data[existing_cols].copy()

        # Rename columns (only for existing columns)
        rename_dict = dict(zip(base_cols, col_names))
        display_data.columns = [rename_dict.get(col, col) for col in existing_cols]

        display_data = display_data.sort_values('% 65+', ascending=False)
        
        st.dataframe(
            display_data.style.background_gradient(subset=['% 65+'], cmap='Blues'),
            use_container_width=True
        )
    
    # TAB 3: Analysis
    with tab3:
        st.subheader("üìà Vulnerability Analysis")
        
        col1, col2 = st.columns(2)
        
        with col1:
            # Distribution histogram
            fig_hist = px.histogram(
                vuln_data,
                x='pct_65plus',
                nbins=10,
                title='Distribution of Elderly Population %',
                labels={'pct_65plus': '% Population 65+', 'count': 'Number of Arrondissements'},
                color_discrete_sequence=['#4472C4']
            )
            st.plotly_chart(fig_hist, use_container_width=True)
            
            # Statistics
            st.markdown("**Statistical Summary:**")
            st.dataframe({
                'Metric': ['Mean', 'Median', 'Std Dev', 'Min', 'Max'],
                '% Elderly': [
                    f"{vuln_data['pct_65plus'].mean():.2f}%",
                    f"{vuln_data['pct_65plus'].median():.2f}%",
                    f"{vuln_data['pct_65plus'].std():.2f}%",
                    f"{vuln_data['pct_65plus'].min():.2f}%",
                    f"{vuln_data['pct_65plus'].max():.2f}%"
                ]
            }, hide_index=True)
        
        with col2:
            # Vulnerability scores
            fig_vuln = px.bar(
                vuln_data.sort_values('vulnerability_score', ascending=False),
                x='CODGEO',
                y='vulnerability_score',
                title='Vulnerability Score by Arrondissement',
                labels={'CODGEO': 'Arrondissement', 'vulnerability_score': 'Vulnerability Score (0-10)'},
                color='vulnerability_score',
                color_continuous_scale='Reds'
            )
            fig_vuln.update_layout(showlegend=False, xaxis_tickangle=-45)
            st.plotly_chart(fig_vuln, use_container_width=True)
            
            # Vulnerability categories
            st.markdown("**Vulnerability Categories:**")
            high_vuln = len(vuln_data[vuln_data['vulnerability_score'] >= 8])
            mod_vuln = len(vuln_data[(vuln_data['vulnerability_score'] >= 6) & (vuln_data['vulnerability_score'] < 8)])
            low_vuln = len(vuln_data[vuln_data['vulnerability_score'] < 6])
            
            st.dataframe({
                'Category': ['üî¥ High (8-10)', 'üü° Moderate (6-7)', 'üü¢ Low (0-5)'],
                'Count': [high_vuln, mod_vuln, low_vuln],
                'Percentage': [
                    f"{high_vuln/len(vuln_data)*100:.1f}%",
                    f"{mod_vuln/len(vuln_data)*100:.1f}%",
                    f"{low_vuln/len(vuln_data)*100:.1f}%"
                ]
            }, hide_index=True)
        
        # Scatter plot: population vs vulnerability
        st.markdown("---")
        fig_scatter = px.scatter(
            vuln_data,
            x='pop_total',
            y='pct_65plus',
            size='pop_65plus',
            text='CODGEO',
            title='Population Size vs Elderly Percentage',
            labels={
                'pop_total': 'Total Population',
                'pct_65plus': '% Population 65+',
                'pop_65plus': 'Elderly Pop'
            },
            color='vulnerability_score',
            color_continuous_scale='RdYlGn_r'
        )
        fig_scatter.update_traces(textposition='top center')
        st.plotly_chart(fig_scatter, use_container_width=True)
    
    # TAB 4: Rankings
    with tab4:
        st.subheader("üîù Arrondissement Rankings")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("### Most Vulnerable")
            st.markdown("*(Highest % elderly population)*")
            
            top_5 = vuln_data.nlargest(5, 'pct_65plus')[['CODGEO', 'pct_65plus', 'pop_65plus', 'vulnerability_score']]
            top_5.columns = ['Arrondissement', '% 65+', 'Pop 65+', 'Vuln Score']
            
            for idx, row in top_5.iterrows():
                st.info(f"""
                **{row['Arrondissement']}**
                - Elderly: {row['% 65+']:.2f}%
                - Population 65+: {row['Pop 65+']:,.0f}
                - Vulnerability: {row['Vuln Score']}/10
                """)
        
        with col2:
            st.markdown("### Least Vulnerable")
            st.markdown("*(Lowest % elderly population)*")
            
            bottom_5 = vuln_data.nsmallest(5, 'pct_65plus')[['CODGEO', 'pct_65plus', 'pop_65plus', 'vulnerability_score']]
            bottom_5.columns = ['Arrondissement', '% 65+', 'Pop 65+', 'Vuln Score']
            
            for idx, row in bottom_5.iterrows():
                st.success(f"""
                **{row['Arrondissement']}**
                - Elderly: {row['% 65+']:.2f}%
                - Population 65+: {row['Pop 65+']:,.0f}
                - Vulnerability: {row['Vuln Score']}/10
                """)
        
        st.markdown("---")
        
        # Key insights
        st.markdown("### üí° Key Insights")
        
        most_vuln = vuln_data.loc[vuln_data['pct_65plus'].idxmax()]
        least_vuln = vuln_data.loc[vuln_data['pct_65plus'].idxmin()]
        
        st.warning(f"""
        **Highest Vulnerability**: {most_vuln['CODGEO']} with {most_vuln['pct_65plus']:.1f}% elderly population
        - This arrondissement may need priority attention during heat waves
        - Consider targeted cooling centers and outreach programs
        """)
        
        st.info(f"""
        **Lowest Vulnerability**: {least_vuln['CODGEO']} with {least_vuln['pct_65plus']:.1f}% elderly population
        - Younger demographic profile
        - Different heat adaptation strategies may be appropriate
        """)
        
        st.markdown("""
        **Paris Context**: The average elderly population across Paris is {:.1f}%, which is slightly below 
        the French national average of ~20%. However, there is significant variation between arrondissements,
        suggesting the need for differentiated heat adaptation strategies.
        """.format(vuln_data['pct_65plus'].mean()))

else:
    st.error("‚ùå Vulnerability data not found!")
    st.info("""
    Please run the population analysis notebook first:
    1. Open `notebooks/02_population_data.ipynb`
    2. Run all cells to generate the vulnerability data
    3. Refresh this page
    """)

# Sidebar
with st.sidebar:
    st.markdown("---")
    st.markdown("### üìñ About Vulnerability")
    st.info("""
    **Why age 65+?**

    Elderly populations are more vulnerable to heat stress due to:
    - Reduced thermoregulation
    - Chronic health conditions
    - Social isolation
    - Limited mobility

    **Age-Based Vulnerability Scoring:**
    - 0-2: Very low (<5% elderly)
    - 3-4: Low (5-10%)
    - 5-6: Moderate (10-15%)
    - 7-8: High (15-20%)
    - 9-10: Very high (>20%)
    """)

    if vuln_data is not None and has_isolation_data:
        st.markdown("---")
        st.markdown("### üè† Isolation Vulnerability")
        st.info("""
        **Why living alone matters:**

        Elderly people living alone face additional heat risks:
        - No one to check on them during heat waves
        - Delayed response to heat-related emergencies
        - Less social support for cooling strategies
        - Higher risk of heat-related mortality

        **Isolation Vulnerability Scoring:**
        - 0-2: Very low (<20% alone)
        - 3-4: Low (20-30%)
        - 5-6: Moderate (30-40%)
        - 7-8: High (40-50%)
        - 9-10: Very high (>50%)

        **Enhanced Score = 60% Age + 40% Isolation**
        """)

    st.markdown("---")
    st.markdown("### üìä Data Sources")
    st.markdown("""
    - **Population**: INSEE 2020
    - **Geography**: Paris Open Data
    - **Climate Zones**: CEREMA
    """)